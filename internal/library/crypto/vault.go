package crypto

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"io"

	"golang.org/x/crypto/hkdf"
)

// VaultConfig contains the parameters required to construct a Vault instance.
type VaultConfig struct {
	KeyMaterial []byte
	Salt        []byte
	Info        string
}

// Vault provides encryption/decryption/digest helpers backed by AES-GCM + HKDF.
type Vault struct {
	key  []byte
	salt []byte
}

// NewVault builds a Vault using HKDF-SHA256 with the provided config.
func NewVault(cfg VaultConfig) (*Vault, error) {
	if len(cfg.KeyMaterial) < 32 {
		return nil, fmt.Errorf("key material must be at least 32 bytes, got %d", len(cfg.KeyMaterial))
	}
	if len(cfg.Salt) == 0 {
		return nil, fmt.Errorf("salt must not be empty")
	}
	if cfg.Info == "" {
		return nil, fmt.Errorf("info must not be empty")
	}

	hkdfReader := hkdf.New(sha256.New, cfg.KeyMaterial, cfg.Salt, []byte(cfg.Info))
	derivedKey := make([]byte, 32)
	if _, err := io.ReadFull(hkdfReader, derivedKey); err != nil {
		return nil, fmt.Errorf("failed to derive key: %w", err)
	}

	return &Vault{
		key:  derivedKey,
		salt: cfg.Salt,
	}, nil
}

// Encrypt encrypts plaintext using AES-256-GCM and returns nonce+ciphertext as []byte.
// This is used internally by agent_token_vault which expects []byte return type.
func (v *Vault) Encrypt(plaintext string) ([]byte, error) {
	block, err := aes.NewCipher(v.key)
	if err != nil {
		return nil, fmt.Errorf("failed to create cipher: %w", err)
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, fmt.Errorf("failed to create GCM: %w", err)
	}

	nonce := make([]byte, gcm.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, fmt.Errorf("failed to generate nonce: %w", err)
	}

	return gcm.Seal(nonce, nonce, []byte(plaintext), nil), nil
}

// EncryptToString encrypts plaintext and returns base64-encoded string.
// This is useful for email credentials storage.
func (v *Vault) EncryptToString(plaintext string) (string, error) {
	ciphertext, err := v.Encrypt(plaintext)
	if err != nil {
		return "", err
	}
	return base64.StdEncoding.EncodeToString(ciphertext), nil
}

// Decrypt decrypts ciphertext generated by Encrypt.
func (v *Vault) Decrypt(ciphertext []byte) (string, error) {
	return decryptAESGCM(v.key, ciphertext)
}

// DecryptFromString decrypts base64-encoded ciphertext string.
func (v *Vault) DecryptFromString(ciphertext string) (string, error) {
	data, err := base64.StdEncoding.DecodeString(ciphertext)
	if err != nil {
		return "", fmt.Errorf("failed to decode base64: %w", err)
	}
	return v.Decrypt(data)
}

// Digest returns SHA-256(salt || plaintext) as []byte for lookup or comparison usage.
func (v *Vault) Digest(plaintext string) ([]byte, error) {
	h := sha256.New()
	if _, err := h.Write(v.salt); err != nil {
		return nil, fmt.Errorf("failed to hash salt: %w", err)
	}
	if _, err := h.Write([]byte(plaintext)); err != nil {
		return nil, fmt.Errorf("failed to hash plaintext: %w", err)
	}
	return h.Sum(nil), nil
}

// DigestToString returns base64-encoded SHA-256 digest.
func (v *Vault) DigestToString(plaintext string) (string, error) {
	digest, err := v.Digest(plaintext)
	if err != nil {
		return "", err
	}
	return base64.StdEncoding.EncodeToString(digest), nil
}

// decryptAESGCM decrypts ciphertext produced by AES-GCM using the provided key.
func decryptAESGCM(key []byte, ciphertext []byte) (string, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return "", fmt.Errorf("failed to create cipher: %w", err)
	}

	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return "", fmt.Errorf("failed to create GCM: %w", err)
	}

	nonceSize := gcm.NonceSize()
	if len(ciphertext) < nonceSize {
		return "", fmt.Errorf("ciphertext too short")
	}

	nonce, encryptedData := ciphertext[:nonceSize], ciphertext[nonceSize:]

	plaintext, err := gcm.Open(nil, nonce, encryptedData, nil)
	if err != nil {
		return "", fmt.Errorf("failed to decrypt: %w", err)
	}

	return string(plaintext), nil
}
